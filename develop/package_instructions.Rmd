
---
title: "PsRank"
author: "Josselin Noirel"
date: "11/09/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, comment=NULL)
```

```{r}
library("survival")
library("snpStats")
library("pROC")
library("matrixStats")
library("caTools")
```

# Package design

```{r, eval=FALSE}
PSRank(plink="filename",
       frac=.5,
       ranking="Z")
```

Parameters

* `frac`: Fraction of the dataset that's used for training:
* `ranking`: What method should be used to rank

# What's to do:

* Check that the $I$ score function works as expected when there are missing values

High priority goals

* Performance

Lower priority goals

* The package could be flexible enough to be able to deal with ad-hoc ranking methods
* The package could be tweaked to allow for simulated genetic data to be used
* The package could be made sensitive to extreme phenotypes (to be discussed)

# Functions

## $I$ score

This should work with missing values

```{r}
I_score = function (genotypes, phenotypes) {
    b  = ! is.na(genotypes)
    Ym = colSums(b * phenotypes)/colSums(b)
    
    n0 = colSums((M0 = genotypes == 0), na.rm=TRUE)
    n1 = colSums((M1 = genotypes == 1), na.rm=TRUE)
    n2 = colSums((M2 = genotypes == 2), na.rm=TRUE)
    n  = n0 + n1 + n2
    
    S  = (colSums(phenotypes * M0, na.rm=TRUE) - n0 * Ym)^2 +
         (colSums(phenotypes * M1, na.rm=TRUE) - n1 * Ym)^2 +
         (colSums(phenotypes * M2, na.rm=TRUE) - n2 * Ym)^2
    
    S/sum((phenotypes - weighted.mean(Ym, n))^2)
}
```

## Usage

```{r, eval=FALSE}
I_score(genotypes, phenotypes)
```

## Arguments

* `genotypes`  should be a $S \times N$ matrix containing 0, 1, 2 or NA;
* `phenotypes` should be a vector of $S$ values for the phenotype; use numeric values for a quantitative trait and booleans for a case/control association study.

# Data

## PLINK format

```{r}
getwd()
fam = "output/unif_Laplace_omni.fam"
bim = "output/unif_Laplace_omni.bim"
bed = "output/unif_Laplace_omni.bed"
dat = read.plink(bed, bim, fam)
```

## R format

Number of SNPs $N$:

```{r}
N = nrow(dat$map)
```

Cohort size $S$

```{r}
size = nrow(dat$fam)
```

Matrix of genotypes

```{r}
genotypes = as.numeric(dat$genotypes)
genotypes[genotypes == 0] = NA
genotypes = matrix(genotypes, nrow=size)
genotypes = genotypes - 1
```

Vector of phenotypes (assuming a case/control study)

```{r}
phenotypes = dat$fam$affected == 2
summary(phenotypes)
```

# Analysis

## One replication

The parameter `frac` refers to the fraction of the dataset that's used for training:

```{r}
frac = .5
```

We split the data into two subsets: training and testing.  It is done in such a way as to preserve the number of cases and controls in all simulations.

```{r}
# Indices of controls and cases (NAs are thrown away)
controls = !is.na(phenotypes) & !phenotypes
cases    = !is.na(phenotypes) &  phenotypes

controls = (1:size)[controls]
cases    = (1:size)[cases]

controls_train = ceiling(frac * length(controls))
controls_test  = length(controls) - controls_train
cases_train    = ceiling(frac * length(cases))
cases_test     = length(cases)    - cases_train
```

```{r}
training = c(sample(controls, size=controls_train),
             sample(cases,    size=cases_train))
training = sort(training)
```

```{r}
testing = setdiff(c(controls, cases), training)
```

The associations are calculated using

```{r}
associations = snp.rhs.estimates(affected ~ 1,
                                 family="binomial",
                                 data=dat$fam[training, ],
                                 snp.data=dat$genotypes[training, ])
```

```{r}
beta    = sapply(associations, FUN=function (x) x$beta)
zscores = sapply(associations, FUN=function (x) x$beta/sqrt(x$Var.beta))
pvalues = 2 * pnorm(-abs(zscores))
iscores = I_score(genotypes[training, ], phenotypes[training])
```

SNPs are ranked according to the $p$-values (or equivalently the $Z$ score)

```{r}
ranking = order(zscores, decreasing=TRUE)
```

Other ranking methods are possible

```{r, eval=FALSE}
ranking_beta = order(abs(beta), decreasing=TRUE)
ranking_iscore = order(iscores, decreasing=TRUE)
ranking_combine = order(zscores + iscores, decreasing=TRUE)
```

Genotypes in the test set are reordered

```{r}
rgenotypes = genotypes[testing, ranking]
rbeta = beta[ranking]
```

If only the sign of $\beta$ coefficients are to be used, then:

```{r, eval=FALSE}
rbeta_sign = sign(rbeta)
```

If there are missing data, we replace the missing values with the expected values (since we assume independence); this could be achieved by centring the genotypes matrix and replacing missing values by zeroes.

```{r}
rgenotypes = t(t(rgenotypes) - colMeans(rgenotypes, na.rm=TRUE))
rgenotypes[is.na(rgenotypes)] = 0
```

We then calculate the polygenic score:

```{r}
polygenic = rowCumsums(t(t(rgenotypes) * rbeta))
          # colCumsums(t(rgenotypes) * rbeta) should yield the same value
```

AUC values are then computed

```{r}
results = c(0.5, colAUC(polygenic, phenotypes[testing])[1, ])
plot(results)
```

(For a quantitative trait, a correlation would be used instead of AUC.)
